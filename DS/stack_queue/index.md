# ADT(Abstract Data Type)

자료구조를 구현하기 위해 필요한 메서드들의 모음이다.

조금 다른말로는 자료구조를 표현하기 위한 클래스

클래스가 사실 메서드의 모음이다. 정확히는 메서드와 프로퍼티의 모음이다. 또한 클래스는 사용자정의 데이터타입이다. ADT가 그래서 Data Type이다.

실제 구현은 안하고 필요한 메서드만 가지고 있다.

예를들면 stack의 메서드에는 pop, push, size, peek 같은 것들이 필요하다. 이걸 모아놓으면 ADT다.

# Stack

stack은 너무나도 자주쓰이고 이미 많이 봤다.

대표적인 LIFO구조다. 주방에 쌓인 접시라고 생각하자. 당연히 접시는 위에서부터 쌓고, 꺼낼때도 위에서부터 꺼낸다.

# Queue

큐는 FIFO다. 그리고 구현이 생각보다 쉽게되지 않는다. 내부적으로 포인터가 두개가 필요하다. front, back으로 두개다.

## Tree와 Graph

Tree와 Graph는 알고리즘 문제에 자주 출제된다. 그래프가 트리보다 조금 큰 집합이다. 그래프인데 출발점(root)이 있으며 circular가 되지 않으면 트리다.

정점을 node, 연결점을 link라고 한다. vertex, edge라고 좀 더 많이 불린다.

### B-Tree

Binary Tree다. 최대 두개의 자식노드를 가질 수 있다. 이게 오른쪽에 큰 수, 왼쪽에 작은 수면 BST(Binary search Tree)다.

이 경우 skewed Tree(불균형트리)라는 문제가 생길 수 있다. 1-2-3-4-5-... 구조의 경우다.

해결방법은 AVL, Red Black Tree와 같은 것이 있다. 별거 없다 이리 뒤집고 저리 뒤집고 한다. 내부적인 알고리즘은 추가적으로 알아보기로 하고 일단은 잘못됨을 감지하면 뒤집는다.

이러한 해결방법으로 균형트리로 만들어준다. 이러한 균형트리는 C++과 같은 언어에서 map 자료구조에서 사용된다.

hash의 경우 탐색의 시간복잡도가 O(1)인데, bst는 O(log n)이다. 비효율적인데 왜쓸까? bst는 1차원으로 압축하면 배열이다. 배열로의 전환이 쉬우므로 중앙값찾기 이런게 엄청 편할 것이다.

### 순회 traversal

모든 노드에 거쳐가는 방법이다. 보통의 경우 재귀로 구현하며 단 세 줄이다. 외워버리면 어떨까?

또한 직접 구현해보고 문제도 풀어보자.

순회는 전위, 중위, 후위 탐색이 있다.

- 전위 나 - 왼쪽 - 오른쪽
- 중위 왼쪽 - 나 - 오른쪽
- 후위 오른쪽 - 왼쪽 - 나

의 순으로 탐색하면 된다.

전위 탐색의 경우

```md
if 현재 노드가 방문하였는가?
안했다면 왼쪽 노드 탐색
그리고 오른쪽 노드 탐색
```

로 pseudo code를 작성할 수 있다.

### 그래프 탐색

지하철 노선도를 생각하면 된다.

풀이방법은 아래와 같다.

- 2차원배열
  - 이 경우 사실 대부분이 비어있다는게 단점
  - 공간복잡도 pow(V)
- 정점마다 1차원 배열
  - 공간복잡도가 낮아짐
  - 공간복잡도 V + E

알고리즘 구현은 2차원배열이 쉽고 빠르다.

### DFS, BFS

깊이우선탐색, 너비우선탐색이라고 한다.

DFS는 스택, BFS는 큐로 구현하면 가능하다.

DFS의 경우 진짜 stack을 이용할 수도 있고 프로그램의 콜스택을 이용하여 재귀로 구현할 수 도 있다.
